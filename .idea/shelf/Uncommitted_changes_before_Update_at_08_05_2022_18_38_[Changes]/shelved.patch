Index: Commands.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Commands.h\"\r\n#include <fcntl.h>\r\n\r\nusing namespace std;\r\n\r\n#if 0\r\n#define FUNC_ENTRY()  \\\r\n  cout << __PRETTY_FUNCTION__ << \" --> \" << endl;\r\n\r\n#define FUNC_EXIT()  \\\r\n  cout << __PRETTY_FUNCTION__ << \" <-- \" << endl;\r\n#else\r\n#define FUNC_ENTRY()\r\n#define FUNC_EXIT()\r\n#define LAST_JOB (-1)\r\n#define MAX_PROCESSES_AMOUNT (100)\r\n#define KILL_SIGNAL_NUM (9)\r\n\r\n#define NO_PID (-1)\r\n#define TAIL_MAX_AMOUNT (3)\r\n#define TAIL_MIN_AMOUNT (2)\r\n#define DEFAULT_LINE_AMOUNT (10)\r\n\r\n#endif\r\n\r\n\r\nconst string WHITESPACE = \" \\n\\r\\t\\f\\v\";\r\n\r\nstring _ltrim(const string &s) {\r\n    size_t start = s.find_first_not_of(WHITESPACE);\r\n    return (start == string::npos) ? \"\" : s.substr(start);\r\n}\r\n\r\nstring _rtrim(const string &s) {\r\n    size_t end = s.find_last_not_of(WHITESPACE);\r\n    return (end == string::npos) ? \"\" : s.substr(0, end + 1);\r\n}\r\n\r\nstring _trim(const string &s) {\r\n    return _rtrim(_ltrim(s));\r\n}\r\n\r\nint _parseCommandLine(const char *cmd_line, char **args) {\r\n    FUNC_ENTRY()\r\n    int i = 0;\r\n    istringstream iss(_trim(string(cmd_line)).c_str());\r\n    for (string s; iss >> s;) {\r\n        args[i] = (char *) malloc(s.length() + 1);\r\n        memset(args[i], 0, s.length() + 1);\r\n        strcpy(args[i], s.c_str());\r\n        args[++i] = NULL;\r\n    }\r\n    return i;\r\n\r\n    FUNC_EXIT()\r\n}\r\n\r\nbool _isBackgroundCommand(const char *cmd_line) {\r\n    const string str(cmd_line);\r\n    return str[str.find_last_not_of(WHITESPACE)] == '&';\r\n}\r\n\r\nvoid _removeBackgroundSign(char *cmd_line) {\r\n    const string str(cmd_line);\r\n    // find last character other than spaces\r\n    unsigned int idx = str.find_last_not_of(WHITESPACE);\r\n    // if all characters are spaces then return\r\n    if (idx == string::npos) {\r\n        return;\r\n    }\r\n    // if the command line does not end with & then return\r\n    if (cmd_line[idx] != '&') {\r\n        return;\r\n    }\r\n    // replace the & (background sign) with space and then remove all tailing spaces.\r\n    cmd_line[idx] = ' ';\r\n    // truncate the command line string up to the last non-space character\r\n    cmd_line[str.find_last_not_of(WHITESPACE, idx) + 1] = 0;\r\n}\r\n\r\n// TODO: Add your implementation for classes in Commands.h\r\n\r\nSmallShell::SmallShell() {\r\n// TODO: add your implementation\r\n}\r\n\r\nSmallShell::~SmallShell() {\r\n// TODO: add your implementation\r\n}\r\n\r\nint findSign(const char *cmd_line, string sign)\r\n{\r\n    char *args[COMMAND_MAX_ARGS];\r\n    int size = _parseCommandLine(cmd_line, args);\r\n\r\n    for (int i = 0; i < size; i++) {\r\n        if (!strcmp(args[i], sign.c_str()))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n/**\r\n* Creates and returns a pointer to Command class which matches the given command line (cmd_line)\r\n*/\r\nCommand *SmallShell::CreateCommand(const char *new_cmd) {\r\n    // For example:\r\n    const char* cmd_line = (char *) malloc(sizeof(char) * strlen(new_cmd));\r\n    strcpy((char*)cmd_line, new_cmd);\r\n    string cmd_s = _trim(string(cmd_line));\r\n    string firstWord = cmd_s.substr(0, cmd_s.find_first_of(\" \\n\"));\r\n\r\n    if ( findSign(cmd_line, \">\") >=0 || findSign(cmd_line, \">>\") >=0 ) {\r\n        return new RedirectionCommand(cmd_line);\r\n    }\r\n\r\n    else if (firstWord == \"chprompt\") {\r\n\r\n        saveChangePrompt(cmd_line);\r\n\r\n    } else if (firstWord == \"jobs\") {\r\n        return new JobsCommand(cmd_line, &extra_jobs);\r\n\r\n    } else if (firstWord == \"fg\") {\r\n        return new ForegroundCommand(cmd_line, &extra_jobs, LAST_JOB);\r\n\r\n    } else if (firstWord == \"bg\") {\r\n        return new BackgroundCommand(cmd_line, &extra_jobs, LAST_JOB);\r\n\r\n    } else if (firstWord == \"showpid\") {\r\n        return new ShowPidCommand(cmd_line);\r\n    } else if (firstWord == \"pwd\") {\r\n        return new GetCurrDirCommand(cmd_line);\r\n    } else if (firstWord == \"cd\") {\r\n        return new ChangeDirCommand(cmd_line, pLastPwd);\r\n    } else if (firstWord == \"kill\") {\r\n        return new KillCommand(cmd_line, &extra_jobs);\r\n    } else if (firstWord == \"quit\") {\r\n        return new QuitCommand(cmd_line, &extra_jobs);\r\n    }\r\n    else if(firstWord == \"tail\"){\r\n        return new TailCommand(cmd_line);\r\n    }\r\n    else if(firstWord == \"touch\"){\r\n        return new TouchCommand(cmd_line);\r\n    }\r\n    else {\r\n        //must be an externalCommand\r\n        return new ExternalCommand(cmd_line);\r\n    }\r\n\r\n    return nullptr;\r\n}\r\n\r\nvoid SmallShell::executeCommand(const char *cmd_line) {\r\n    // TODO: Add your implementation here\r\n    // for example:\r\n    // Command* cmd = CreateCommand(cmd_line);\r\n    // cmd->execute();\r\n    // Please note that you must fork smash process for some commands (e.g., external commands....)\r\n\r\n    Command *cmd = CreateCommand(cmd_line);\r\n    if(cmdIsChprompt(cmd_line)){\r\n        return;\r\n    }\r\n    cmd->execute();\r\n}\r\n\r\n\r\nvoid JobsCommand::execute() {\r\n    //the function needs to print out all the jobs in the bg or the ones that stopped.\r\n    extra_jobs->printJobsList();\r\n}\r\n\r\nvoid ForegroundCommand::execute() {\r\n//the function brings either a bg process or a stopped process to fg\r\n\r\n    char *args[COMMAND_MAX_ARGS];\r\n    int job_number = SmallShell::checkSyntaxForeGroundBackground(cmd_line, args);\r\n    if (job_number < LAST_JOB) {\r\n        cerr << \"smash error: fg: invalid arguments\" << endl;\r\n        return;\r\n    }\r\n    this->jobId = job_number;\r\n\r\n    if (this->jobId != LAST_JOB && !jobs_list_fg->jobExists(this->jobId)) {\r\n\r\n        cerr << \"smash error: fg: job-id \" << this->jobId <<\" does not exist\" << endl;\r\n        return;\r\n    } else if (this->jobId == LAST_JOB && jobs_list_fg->isEmpty()) {\r\n        cerr << \"smash error: fg: jobs list is empty\" << endl;\r\n        return;\r\n    }\r\n    JobsList::JobEntry *chosen_job;\r\n\r\n    if (this->jobId == LAST_JOB) {\r\n        chosen_job = jobs_list_fg->getLastJob(nullptr);\r\n        this->jobId = chosen_job->getJobId();\r\n    } else {\r\n        chosen_job = jobs_list_fg->getJobById(this->jobId);\r\n    }\r\n\r\n    if (chosen_job->getStopped()) {\r\n        int ret = kill(chosen_job->getJobPid(), SIGCONT);\r\n        if(ret < 0){\r\n            // * failed to send sigcont to prcess\r\n            perror(\"smash error: kill failed\");\r\n        }\r\n\r\n    }\r\n    cout << chosen_job->getCmdInput() << \" : \" << chosen_job->getJobPid() << \"\\n\";\r\n    waitpid(chosen_job->getJobPid(), nullptr, WUNTRACED);\r\n    jobs_list_fg->removeJobById(jobId);\r\n\r\n\r\n}\r\n\r\n\r\nvoid BackgroundCommand::execute() {\r\n    char *args[COMMAND_MAX_ARGS];\r\n    int job_number = SmallShell::checkSyntaxForeGroundBackground(cmd_line, args);\r\n    if (job_number < LAST_JOB) {\r\n        cerr << \"smash error: bg: invalid arguments\" << endl;\r\n        return;\r\n    }\r\n\r\n    this->jobIdBackground = job_number;\r\n    //the function brings a stopped process to bg\r\n    if (this->jobIdBackground != LAST_JOB && !jobs_list_background->jobExists(this->jobIdBackground)) {\r\n        cerr << \"smash error: bg: job-id \" << this->jobIdBackground <<\" does not exist\" << endl;\r\n        return;\r\n    } else if (this->jobIdBackground == LAST_JOB && jobs_list_background->isEmpty()) {\r\n        cerr << \"smash error: bg: jobs list is empty\" << endl;\r\n        return;\r\n    }\r\n    JobsList::JobEntry* stopped_job;\r\n\r\n    if(jobIdBackground == LAST_JOB) {\r\n        try {\r\n            stopped_job = jobs_list_background->getLastStoppedJob();\r\n            this->jobIdBackground = stopped_job->getJobId();\r\n        }\r\n        catch(exception&){\r\n            cerr << \"smash error: bg: there is no stopped jobs to resume\" << endl;\r\n            return;\r\n        }\r\n    }\r\n    else{\r\n        stopped_job = jobs_list_background->getJobById(this->jobIdBackground);\r\n    }\r\n    cout << stopped_job->getCmdInput() << \": \" << this->jobIdBackground;\r\n     stopped_job->ChangeStopped();\r\n    int ret = kill(stopped_job->getJobPid(), SIGCONT);\r\n    if(ret < 0){\r\n        // * failed to send sigcont to prcess\r\n        perror(\"smash error: kill failed\");\r\n    }\r\n\r\n}\r\n\r\nvoid ExternalCommand::execute() {\r\n    char* args[COMMAND_MAX_ARGS];\r\n    _parseCommandLine(cmd_line, args);\r\n    pid_t c_pid = fork();\r\n    if(c_pid == -1){\r\n        perror(\"smash error: fork failed\");\r\n    }\r\n    char* run_in_bash = (char*) malloc(sizeof(char*) * strlen(cmd_line));\r\n    strcpy(run_in_bash, cmd_line);\r\n    _removeBackgroundSign(run_in_bash);\r\n\r\n    if(c_pid == 0){\r\n        setpgrp();\r\n        //we're in the child process\r\n        char* const args_for_bash[4] = {(char*) \"/bin/bash\",(char*)\"-c\", run_in_bash, nullptr};\r\n        execv(args_for_bash[0], args_for_bash);\r\n        //if this returned, something wrong happened\r\n        throw exception();\r\n    }\r\n    else{\r\n        //we're in the parent process\r\n        if(_isBackgroundCommand(cmd_line)){\r\n            //runs in background\r\n\r\n            SmallShell& smash = SmallShell::getInstance();\r\n            pid = int(c_pid); //changing the default pid to relevant pid\r\n            smash.extra_jobs.addJob(this, false);\r\n        }\r\n        else{\r\n            //runs in the foreground\r\n            waitpid(c_pid, nullptr, 0);\r\n        }\r\n    }\r\n}\r\n\r\nvoid TailCommand::execute() {\r\n    char* args[COMMAND_MAX_ARGS];\r\n    bool valid;\r\n    int args_num;\r\n    size_t lines_from_end = checkSyntaxTail(cmd_line, args, &valid);\r\n    args_num = _parseCommandLine(cmd_line, args);\r\n    if(!valid){\r\n        cerr << \"smash error: tail: invalid arguments\" << endl;\r\n        return;\r\n    }\r\n\r\n    size_t i, count;\r\n     string file_name =  _trim(args[args_num - 1]);\r\n    try{\r\n        count = count_lines((char*)file_name.c_str());\r\n    }\r\n    catch(std::exception&){\r\n        return;\r\n    }\r\n\r\n    string line;\r\n    if(count < lines_from_end){\r\n        lines_from_end = count;\r\n    }\r\n\r\n    std::ifstream tail_file(file_name, std::ifstream::in); //if not working then open will print the error\r\n    if(!tail_file.is_open()){\r\n        perror(\"smash error: open failed\");\r\n        return;\r\n    }\r\n\r\n    for (i = 0; i < count - lines_from_end; ++i){\r\n        getline(tail_file, line); /* read and discard: skip line */\r\n    }\r\n    while (getline(tail_file, line)){\r\n        cout << line << endl;\r\n    }\r\n    tail_file.close();\r\n\r\n}\r\n\r\nvoid TouchCommand::execute() {\r\n    char* args[COMMAND_MAX_ARGS];\r\n    bool valid;\r\n    int args_num;\r\n    valid = checkSyntaxTouch(cmd_line, args);\r\n    args_num = _parseCommandLine(cmd_line, args);\r\n    if(!valid){\r\n        cerr << \"smash error: touch: invalid arguments\" << endl;\r\n        return;\r\n    }\r\n    string time_str =  _trim(args[args_num - 1]);\r\n    const char* file_str = _trim(args[1]).c_str();\r\n    std::ifstream f(file_str, std::ifstream::in); //if not working then open will print the error\r\n    if(!f.is_open()){\r\n        perror(\"smash error: open failed\");\r\n        return;\r\n    }\r\n    f.close();\r\n    std::string delimiter = \":\";\r\n    size_t curr_index;\r\n    int time_arr[6];\r\n    for (int & i : time_arr) {\r\n        curr_index = time_str.find(delimiter);\r\n        i = stoi(time_str.substr(0, curr_index));\r\n        time_str = time_str.substr(curr_index + 1);\r\n\r\n    }\r\n    struct tm new_file_time = {\r\n            .tm_sec = time_arr[0],\r\n            .tm_min = time_arr[1],\r\n            .tm_hour = time_arr[2],\r\n            .tm_mday = time_arr[3],\r\n            .tm_mon = time_arr[4] - 1,\r\n            .tm_year = time_arr[5] - 1900,\r\n            .tm_wday = 0,\r\n            .tm_yday = 0,\r\n            .tm_isdst = 0\r\n    };\r\n\r\n    tm *time_info = &new_file_time;\r\n    time_t time_ret = mktime(time_info);\r\n    if(time_ret == -1){\r\n        perror(\"smash error: mktime failed\");\r\n        return;\r\n    }\r\n    const struct utimbuf time_buf = {time_ret, time_ret};\r\n    int ret_utime = utime(file_str, &time_buf);\r\n    if(ret_utime == -1){\r\n        perror(\"smash error: utime failed\");\r\n        return;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\nconst string &SmallShell::getCurrPrompt() {\r\n    return curr_prompt;\r\n}\r\n\r\nvoid SmallShell::setCurrPrompt(const string &s) {\r\n    this->curr_prompt = s;\r\n}\r\n\r\nvoid SmallShell::saveChangePrompt(const char *cmd) {\r\n    char *args[COMMAND_MAX_ARGS];\r\n    int num_args = _parseCommandLine(cmd, args);\r\n    SmallShell &smash = SmallShell::getInstance();\r\n\r\n    if (num_args == 1) {\r\n        smash.setCurrPrompt(smash.default_prompt);\r\n    } else {\r\n        string new_prompt = string(args[1]).append(string(\"> \"));\r\n        smash.setCurrPrompt(new_prompt);\r\n    }\r\n}\r\n\r\nbool SmallShell::isNumber(char *string) {\r\n    size_t len = strlen(string);\r\n    for (size_t i = 0; i < len; i++) {\r\n        if (!isdigit(string[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nint SmallShell::checkSyntaxForeGroundBackground(const char *line, char **args) {\r\n    int job;\r\n    int args_amount = _parseCommandLine(line, args);\r\n\r\n    if (args_amount == 2 && isNumber(args[1])) {\r\n        job = atoi(args[1]);\r\n    } else if (args_amount == 1) {\r\n        job = LAST_JOB;\r\n    } else {\r\n        job = LAST_JOB - 1;\r\n    }\r\n    return job;\r\n}\r\n\r\nbool SmallShell::cmdIsChprompt(const char *line) {\r\n    string cmd_s = _trim(string(line));\r\n    string firstWord = cmd_s.substr(0, cmd_s.find_first_of(\" \\n\"));\r\n    return firstWord == \"chprompt\";\r\n\r\n}\r\n\r\nvoid JobsList::addJob(Command *cmd, bool isStopped) {\r\n    //the function receives a command and if the proccess stopped and puts it in the jobs list\r\n    removeFinishedJobs();\r\n    int curr_job_id;\r\n\r\n    if((curr_job_id = AlreadyExists(cmd->getCommandPid())) != -1){\r\n        JobEntry* curr_entry = getJobById(curr_job_id);\r\n        time_t curr_time = time(nullptr);\r\n        if(curr_time == -1){\r\n            perror(\"smash error: time failed\");\r\n            return;\r\n        }\r\n        curr_entry->time_entered = curr_time;\r\n    }\r\n    max_jobId++;\r\n    time_t time_added = time(nullptr);\r\n\r\n    if(time_added == -1){\r\n        perror(\"smash error: time failed\");\r\n        return;\r\n    }\r\n    JobEntry *new_job = new JobEntry(cmd->getCommandPid(), max_jobId, cmd->getLine(), isStopped, time_added);\r\n    job_ids[max_jobId] = jobs.insert(jobs.end(), new_job); // hash[jobid] = pointer to the new element in linked list\r\n\r\n\r\n}\r\n\r\nvoid JobsList::printJobsList() {\r\n    //the function prints all the jobs in bg or that stopped based on the\r\n    removeFinishedJobs();\r\n    for (auto &job: jobs) {\r\n        int curr_job_id = job->job_id;\r\n        const char *input = job->cmd_input;\r\n        int curr_pid = job->pid;\r\n        time_t status_time = time(nullptr);\r\n        cout << \"[\" << curr_job_id << \"] \" << input << \" :\" << curr_pid << \" \" << difftime(status_time, job->time_entered);\r\n\r\n        if (job->stopped) {\r\n            cout << \" (stopped)\";\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n}\r\n\r\nvoid JobsList::removeFinishedJobs() {\r\n    //The function removes all jobs from linked list and hash that finished\r\n\r\n    int kid_pid = waitpid(-1, nullptr, WNOHANG);\r\n    while (kid_pid > 0) {\r\n        int job_id = findJobId(kid_pid);\r\n        removeJobById(job_id);\r\n        kid_pid = waitpid(-1, nullptr, WNOHANG);\r\n    }\r\n}\r\n\r\nJobsList::JobEntry *JobsList::getJobById(int jobId) {\r\n    if (job_ids.find(jobId) == job_ids.end()) {\r\n\r\n        throw exception(); //! error, not a valid job id\r\n    }\r\n    list<JobEntry *>::iterator it = job_ids[jobId];\r\n    return *it;\r\n\r\n}\r\n\r\nvoid JobsList::removeJobById(int jobId) {\r\n    //! maybe need to handle errors like non-existing jobId or empty list\r\n    if (job_ids.find(jobId) == job_ids.end()) {\r\n        throw exception(); //! error, not a valid job id\r\n    }\r\n\r\n    list<JobEntry *>::iterator it = job_ids[jobId];\r\n    jobs.erase(it);\r\n    job_ids.erase(jobId);\r\n\r\n}\r\n\r\nJobsList::JobEntry *JobsList::getLastJob(int *lastJobId) {\r\n    if (job_ids.find(*lastJobId) == job_ids.end()) {\r\n        throw exception(); //! error, not a valid job id\r\n    }\r\n    JobEntry *last_entry = jobs.back();\r\n    return last_entry;\r\n}\r\n\r\nJobsList::JobEntry *JobsList::getLastStoppedJob() {\r\n    for (auto rit = jobs.rbegin(); rit != jobs.rend(); ++rit) { //going through list backwards\r\n        if ((*rit)->stopped) {\r\n            return *rit;\r\n        }\r\n    }\r\n    //! no job has stopped, throw error\r\n    throw exception();\r\n}\r\n\r\nint JobsList::findJobId(int pid) {\r\n    for (auto &job: jobs) {\r\n        if (job->pid == pid) {\r\n            return job->job_id;\r\n        }\r\n    }\r\n    //! should not get here, must mean pid not a process running in bg or stopped\r\n    throw exception();\r\n}\r\n\r\nJobsList::JobsList() {\r\n    max_jobId = 0;\r\n    jobs = list<JobEntry *>();\r\n    job_ids = unordered_map<int, list<JobEntry *>::iterator>();\r\n}\r\n\r\nbool JobsList::isEmpty() const {\r\n    return jobs.empty();\r\n}\r\n\r\nbool JobsList::jobExists(int jobId) {\r\n    if (job_ids.find(jobId) == job_ids.end())\r\n        return false;\r\n\r\n    return true;\r\n}\r\n\r\nint JobsList::AlreadyExists(int pid) {\r\n    for(auto it = jobs.begin(); it != jobs.end(); ++it){\r\n        if((*it)->pid == pid)\r\n            return (*it)->job_id;\r\n    }\r\n    return -1;\r\n}\r\n\r\nint Command::getCommandPid() const {\r\n    return pid;\r\n}\r\n\r\nconst char *Command::getLine() {\r\n    return cmd_line;\r\n}\r\n\r\nCommand::Command(const char *cmd_line): cmd_line(cmd_line) {\r\n        pid = NO_PID;\r\n}\r\n\r\nvoid Command::setPid(int new_pid) {\r\n    this->pid = new_pid;\r\n}\r\n\r\nJobsList::JobEntry::JobEntry(int pid, int job_id, const char *cmd_input, bool stopped, time_t start_time) : pid(pid),\r\n                                                                                                            job_id(job_id),\r\n                                                                                                            cmd_input(\r\n                                                                                                                    cmd_input),\r\n                                                                                                            stopped(stopped),\r\n                                                                                                            time_entered(\r\n                                                                                                                    start_time) {}\r\n\r\nint JobsList::JobEntry::getJobPid() const {\r\n    return pid;\r\n}\r\n\r\nbool JobsList::JobEntry::getStopped() const {\r\n    return stopped;\r\n}\r\n\r\nconst char *JobsList::JobEntry::getCmdInput() {\r\n    return cmd_input;\r\n}\r\n\r\nint JobsList::JobEntry::getJobId() const {\r\n    return job_id;\r\n}\r\n\r\nvoid JobsList::JobEntry::ChangeStopped() {\r\n    stopped = 1 - stopped;\r\n}\r\n\r\nBuiltInCommand::BuiltInCommand(const char *cmd_line) : Command(cmd_line) {}\r\n\r\nJobsCommand::JobsCommand(const char *cmdLine, JobsList *jobs) : BuiltInCommand(cmdLine), extra_jobs(jobs) {\r\n\r\n}\r\n\r\nForegroundCommand::ForegroundCommand(const char *cmd_line, JobsList *jobs, int job_number) : BuiltInCommand(cmd_line),\r\n                                                                                             jobId(job_number),\r\n                                                                                             jobs_list_fg(jobs)\r\n                                                                                              {}\r\n\r\nBackgroundCommand::BackgroundCommand(const char *cmd_line, JobsList *jobs, int job_number) :\r\n        BuiltInCommand(cmd_line),\r\n        jobIdBackground(job_number), jobs_list_background(jobs) {}\r\n\r\nExternalCommand::ExternalCommand(const char *cmd_line) : Command(cmd_line) {\r\n\r\n}\r\n\r\n/**                           showpid Function                                  **/\r\nShowPidCommand::ShowPidCommand(const char *cmd_line) : BuiltInCommand(cmd_line) {}\r\n\r\nvoid ShowPidCommand::execute()\r\n{\r\n    cout << \"smash pid is \" << getpid() << endl;\r\n}\r\n\r\nGetCurrDirCommand::GetCurrDirCommand(const char *cmd_line) : BuiltInCommand(cmd_line) {}\r\n\r\nvoid GetCurrDirCommand::execute()\r\n{\r\n    char buf[PATH_MAX];\r\n    if (getcwd(buf, sizeof(buf)) == NULL)\r\n    {\r\n        perror(\"smash error: getcwd failed\");\r\n        return;\r\n    }\r\n    cout << buf << endl;\r\n\r\n}\r\n\r\nChangeDirCommand::ChangeDirCommand(const char *cmd_line, string &plastPwd) : BuiltInCommand(cmd_line), plastPwd(plastPwd) {}\r\n\r\nvoid ChangeDirCommand::execute()\r\n{\r\n\r\n    char *args[COMMAND_MAX_ARGS];\r\n    int args_amount = _parseCommandLine(cmd_line, args);\r\n    if (args_amount != 2)\r\n    {\r\n        cerr << \"smash error: cd: too many arguments\" << endl;\r\n        return;\r\n    }\r\n\r\n    //saving my current dir\r\n    char buf[PATH_MAX];\r\n    if (getcwd(buf, sizeof(buf)) == NULL)\r\n    {\r\n        perror(\"smash error: getcwd failed\");\r\n        return;\r\n    }\r\n\r\n    if (!strcmp(args[1], \"-\"))\r\n    {\r\n        if (plastPwd == \"\")\r\n        {\r\n            cerr << \"smash error: cd: OLDPWD not set\" << endl;\r\n            return;\r\n        }\r\n        if(chdir(plastPwd.c_str()) == -1)\r\n        {\r\n            perror(\"smash error: chdir failed\");\r\n            return;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if(chdir(args[1]) == -1)\r\n        {\r\n            perror(\"smash error: chdir failed\");\r\n            return;\r\n        }\r\n    }\r\n    plastPwd = string(buf);\r\n}\r\n\r\n\r\nKillCommand::KillCommand(const char *cmd_line, JobsList *jobs): BuiltInCommand(cmd_line), extra_jobs(jobs) {}\r\n\r\n\r\n\r\n\r\n\r\nvoid KillCommand::execute()\r\n{\r\n    char *args[COMMAND_MAX_ARGS];\r\n    JobsList::JobEntry* job = nullptr;\r\n    int args_amount = _parseCommandLine(cmd_line, args);\r\n    if (args_amount != 3)\r\n    {\r\n        cerr << \"smash error: kill: invalid arguments\" << endl;\r\n        return;\r\n    }\r\n\r\n    try {\r\n        job = extra_jobs->getJobById(atoi(args[2]));\r\n    } catch (...) {\r\n        cerr << \"smash error: kill: job-id \" << args[2] << \" does not exist\" << endl;\r\n        return;\r\n    }\r\n\r\n    if (kill(job->getJobPid(), abs(atoi(args[1]))) == -1)\r\n    {\r\n        perror(\"smash error: kill failed\");\r\n    }\r\n}\r\n\r\nTailCommand::TailCommand(const char *cmd_line) : BuiltInCommand(cmd_line) {\r\n}\r\n\r\nsize_t TailCommand::checkSyntaxTail(const char *line, char **args, bool *valid) {\r\n    int arg_amount = _parseCommandLine(line, args);\r\n    if(arg_amount > TAIL_MAX_AMOUNT || arg_amount < TAIL_MIN_AMOUNT){\r\n        *valid = false;\r\n        return 0;\r\n    }\r\n    if(arg_amount == TAIL_MIN_AMOUNT){\r\n        *valid = true;\r\n        return DEFAULT_LINE_AMOUNT;\r\n    }\r\n    else{\r\n        // * three parameters and the second one is a number\r\n        std::string number_str = args[1];\r\n        std::string sub = number_str.substr(1);\r\n        const char* c_sub = sub.c_str();\r\n        // moving to char* the number without the negative sign\r\n\r\n        if(!SmallShell::isNumber((char*)c_sub) || number_str.at(0) != '-') {\r\n            *valid = false;\r\n            return 0;\r\n        }\r\n        *valid = true;\r\n        return std::stoul(number_str.substr(1));\r\n    }\r\n}\r\n\r\nsize_t TailCommand::count_lines(char *buf) {\r\n    std::ifstream tail_file(buf, std::ifstream::in);\r\n    if(!tail_file.is_open()){\r\n        perror(\"smash error: open failed\");\r\n        throw std::exception();\r\n    }\r\n    string line;\r\n    size_t counter = 0;\r\n    while (getline(tail_file, line)){\r\n       counter++;\r\n    }\r\n    tail_file.close();\r\n    return counter;\r\n}\r\n\r\nTouchCommand::TouchCommand(const char *cmd_line) : BuiltInCommand(cmd_line) {\r\n\r\n}\r\n\r\nbool TouchCommand::checkSyntaxTouch(const char *line, char **args) {\r\n    int args_len = _parseCommandLine(line, args);\r\n    if(args_len != 3){\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nQuitCommand::QuitCommand(const char *cmd_line, JobsList *jobs):BuiltInCommand(cmd_line),extra_jobs(jobs){}\r\n\r\nvoid QuitCommand::execute()\r\n{\r\n    char *args[COMMAND_MAX_ARGS];\r\n    int args_amount = _parseCommandLine(cmd_line, args);\r\n     if (args_amount > 1 && !strcmp(args[1], \"kill\"))\r\n     {\r\n         list<JobsList::JobEntry *>::iterator it;\r\n         cout << \"smash: sending SIGKILL signal to \" << extra_jobs->jobs.size() << \" jobs:\" << endl;\r\n         for (it = (extra_jobs->jobs).begin(); it != (extra_jobs->jobs).end(); ++it)\r\n         {\r\n             cout << (*it)->getJobPid() << \": \" << (*it)->getCmdInput() << endl;\r\n             if (kill((*it)->getJobPid(),KILL_SIGNAL_NUM) == -1)\r\n             {\r\n                 perror(\"smash error: kill failed\");\r\n             }\r\n         }\r\n     }\r\n    exit(EXIT_SUCCESS);\r\n}\r\n\r\n\r\n\r\n\r\nRedirectionCommand::RedirectionCommand(const char *cmd_line) : Command(cmd_line) {}\r\n\r\nvoid RedirectionCommand::execute()\r\n{\r\n\r\n    char* args[COMMAND_MAX_ARGS];\r\n    _parseCommandLine(cmd_line, args);\r\n    char executed_cmd[strlen(cmd_line) + 1];\r\n    strcpy(executed_cmd, cmd_line);\r\n\r\n    int sign_place_one = findSign(cmd_line, \">\");\r\n    int sign_place_two = findSign(cmd_line, \">>\");\r\n    if (sign_place_one != -1)\r\n    {\r\n        pid_t pid = fork();\r\n        if (pid == 0)\r\n        {\r\n            close(1);\r\n            open(args[sign_place_one + 1], O_CREAT | O_RDWR | O_TRUNC, \"w\");\r\n            char* sym_pos = strstr(executed_cmd, \">\");\r\n            *sym_pos = '\\0';\r\n            (SmallShell::getInstance()).executeCommand(executed_cmd);\r\n            exit(0);\r\n        } else {\r\n            wait(NULL);\r\n        }\r\n        return;\r\n    }\r\n    if (sign_place_two != -1)\r\n    {\r\n        pid_t pid = fork();\r\n        if (pid == 0)\r\n        {\r\n            close(1);\r\n            open(args[sign_place_two + 1], O_CREAT | O_APPEND | O_RDWR, \"w\");\r\n            char* sym_pos = strstr(executed_cmd, \">\");\r\n            *sym_pos = '\\0';\r\n            (SmallShell::getInstance()).executeCommand(executed_cmd);\r\n            exit(0);\r\n        } else {\r\n            wait(NULL);\r\n        }\r\n        return;\r\n\r\n    }\r\n    return;\r\n\r\n}\r\n\r\n\r\nPipeCommand::PipeCommand(const char *cmd_line) : Command(cmd_line) {}\r\n\r\nvoid PipeCommand::execute()\r\n{\r\n\r\n    char* args[COMMAND_MAX_ARGS];\r\n    _parseCommandLine(cmd_line, args);\r\n    char executed_cmd[strlen(cmd_line) + 1];\r\n    strcpy(executed_cmd, cmd_line);\r\n\r\n    int my_pipe[2];\r\n    pipe(my_pipe);\r\n\r\n    int sign_place_one = findSign(cmd_line, \"|\");\r\n    int sign_place_two = findSign(cmd_line, \"|&\");\r\n    if (sign_place_one != -1)\r\n    {\r\n        if (fork() == 0)\r\n        {\r\n            if (fork() == 0)\r\n            {\r\n                dup2(my_pipe[0], 0);\r\n                close(my_pipe[0]);\r\n                close(my_pipe[1]);\r\n                char *sym_pos = strstr(executed_cmd, \"|\");\r\n                wait(NULL);\r\n                (SmallShell::getInstance()).executeCommand(sym_pos + 1);\r\n                exit(EXIT_SUCCESS);\r\n            } else\r\n            {\r\n                dup2(my_pipe[1], 1);\r\n                close(my_pipe[0]);\r\n                close(my_pipe[1]);\r\n                char *sym_pos = strstr(executed_cmd, \"|\");\r\n                *sym_pos = '\\0';\r\n                (SmallShell::getInstance()).executeCommand(executed_cmd);\r\n                exit(EXIT_SUCCESS);\r\n            }\r\n        } else {\r\n            close(my_pipe[0]);\r\n            close(my_pipe[1]);\r\n            wait(NULL);\r\n        }\r\n        return;\r\n    }\r\n    if (sign_place_two != -1)\r\n    {\r\n        if (fork() == 0)\r\n        {\r\n            if (fork() == 0)\r\n            {\r\n                dup2(my_pipe[0], 0);\r\n                close(my_pipe[0]);\r\n                close(my_pipe[1]);\r\n                char *sym_pos = strstr(executed_cmd, \"|\");\r\n                wait(NULL);\r\n                (SmallShell::getInstance()).executeCommand(sym_pos + 1);\r\n                exit(EXIT_SUCCESS);\r\n            } else\r\n            {\r\n                dup2(my_pipe[1], 2);\r\n                close(my_pipe[0]);\r\n                close(my_pipe[1]);\r\n                char *sym_pos = strstr(executed_cmd, \"|\");\r\n                *sym_pos = '\\0';\r\n                (SmallShell::getInstance()).executeCommand(executed_cmd);\r\n                exit(EXIT_SUCCESS);\r\n            }\r\n        } else {\r\n            close(my_pipe[0]);\r\n            close(my_pipe[1]);\r\n            wait(NULL);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Commands.cpp b/Commands.cpp
--- a/Commands.cpp	(revision 1cf6d8bf68afe78ffcf5f87ba1d7986789cf5bd8)
+++ b/Commands.cpp	(date 1652024297262)
@@ -247,9 +247,10 @@
     }
     else{
         stopped_job = jobs_list_background->getJobById(this->jobIdBackground);
+
     }
     cout << stopped_job->getCmdInput() << ": " << this->jobIdBackground;
-     stopped_job->ChangeStopped();
+    stopped_job->ChangeStopped();
     int ret = kill(stopped_job->getJobPid(), SIGCONT);
     if(ret < 0){
         // * failed to send sigcont to prcess
